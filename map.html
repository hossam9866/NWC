<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Locations Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- ArcGIS CSS -->
  <link rel="stylesheet" href="https://js.arcgis.com/4.29/esri/themes/light/main.css" />

  <style>
    html, body { height: 100%; margin: 0; }
    #viewDiv { height: 100%; width: 100%; }

    #status{
      position:absolute;top:12px;left:12px;z-index:10;
      background:rgba(0,0,0,.75);color:#fff;padding:10px 14px;border-radius:10px;
      font-family:Arial,sans-serif;font-size:13px;max-width:360px;white-space:pre-wrap;
      pointer-events:none;
    }

    #controls{
      position:absolute;top:12px;right:12px;z-index:11;
      display:none;gap:8px;flex-wrap:wrap;
      max-width:min(520px, calc(100vw - 24px));
      justify-content:flex-end;
    }
    #controls button{
      pointer-events:auto;cursor:pointer;border:0;border-radius:999px;
      padding:8px 12px;font:13px Arial,sans-serif;color:#fff;
      background:rgba(0,0,0,.65);transition:transform .12s ease, background .12s ease;
    }
    #controls button:hover{ background:rgba(0,0,0,.82); transform:translateY(-1px); }
    #controls button:active{ transform:translateY(0); }
    #controls button.primary{ background:rgba(44,62,80,.92); }
  </style>

  <!-- ArcGIS JS -->
  <script src="https://js.arcgis.com/4.29/"></script>
</head>

<body>
  <div id="status">Reading locations from URL…</div>
  <div id="controls"></div>
  <div id="viewDiv"></div>

  <script>
    const statusEl = document.getElementById("status");
    const controlsEl = document.getElementById("controls");

    function setStatus(msg) { statusEl.textContent = msg; }

    // ============================
    // Read "location" from URL
    // ============================
    function readLocationsFromUrl() {
      const query = location.search || "";
      const match = query.match(/[?&]location=(.*)$/);
      if (!match) return [];

      const raw = match[1];

      // Try JSON (already decoded)
      try { return JSON.parse(raw); } catch (_) {}

      // Try decoded JSON
      try { return JSON.parse(decodeURIComponent(raw)); } catch (_) {}

      return [];
    }

    // Optional params
    const sp = new URLSearchParams(location.search);
    const basemap = sp.get("basemap") || "streets-vector";
    const zoom = Number(sp.get("zoom") || "6");
    const centerStr = sp.get("center");
    const center = centerStr ? centerStr.split(",").map(x => Number(x)) : [47, 25];

    const locations = readLocationsFromUrl();
    const total = Array.isArray(locations) ? locations.length : 0;

    // Keep polygon OR circle (do NOT filter circle out)
    const validItems = Array.isArray(locations)
      ? locations.filter(l =>
          l &&
          (
            (Array.isArray(l.points) && l.points.length >= 3) ||
            (l.latitude != null && l.longitude != null && l.radius != null)
          )
        )
      : [];

    setStatus(
      `basemap: ${basemap}\nzoom: ${zoom}\ncenter: ${center.join(",")}\nitems: ${validItems.length}/${total}`
    );

    if (!validItems.length) {
      setStatus(statusEl.textContent + "\n\n❌ No valid locations (polygon/circle).");
      throw new Error("No valid locations");
    }

    // ============================
    // ArcGIS Map (Polygon + Circle)
    // ============================
    require([
      "esri/Map",
      "esri/views/MapView",
      "esri/Graphic",
      "esri/geometry/Polygon",
      "esri/geometry/Circle",
      "esri/geometry/Extent"
    ], function (Map, MapView, Graphic, Polygon, Circle, Extent) {

      function hexToRgba(hex, opacity = 35) {
        let h = String(hex || "#2f6f9e").replace("#", "");
        if (h.length === 3) h = h[0]+h[0]+h[1]+h[1]+h[2]+h[2];
        const r = parseInt(h.substring(0, 2) || "00", 16);
        const g = parseInt(h.substring(2, 4) || "00", 16);
        const b = parseInt(h.substring(4, 6) || "00", 16);
        const a = Math.max(0, Math.min(1, (Number(opacity) || 35) / 100));
        return `rgba(${r},${g},${b},${a})`;
      }

      function buildGeometry(item) {
        // ✅ Polygon
        if (Array.isArray(item.points) && item.points.length >= 3) {
          const ring = item.points.map(p => [Number(p[0]), Number(p[1])]);

          // close ring
          const first = ring[0];
          const last  = ring[ring.length - 1];
          if (first && last && (first[0] !== last[0] || first[1] !== last[1])) {
            ring.push([first[0], first[1]]);
          }

          return new Polygon({
            rings: [ring],
            spatialReference: { wkid: 4326 }
          });
        }

        // ✅ Circle (radius in meters)
        if (item.latitude != null && item.longitude != null && item.radius != null) {
          return new Circle({
            center: [Number(item.longitude), Number(item.latitude)],
            radius: Number(item.radius),
            radiusUnit: "meters"
          });
        }

        return null;
      }

      const map = new Map({ basemap });

      const view = new MapView({
        container: "viewDiv",
        map,
        zoom: Number.isFinite(zoom) ? zoom : 6,
        center: (Array.isArray(center) && center.length === 2) ? center : [47, 25]
      });

      view.when(async () => {
        const items = [];

        validItems.forEach((loc, i) => {
          const geom = buildGeometry(loc);
          if (!geom) return;

          // Circle can use simple-fill (it becomes a polygon shape)
          const graphic = new Graphic({
            geometry: geom,
            symbol: {
              type: "simple-fill",
              color: hexToRgba(loc.fill || "#2f6f9e", loc.opacity ?? 35),
              outline: {
                color: loc.outline || "#05538c",
                width: 2
              }
            },
            attributes: {
              name: loc.name || `Location ${i + 1}`
            }
          });

          items.push({ loc, graphic });
        });

        if (!items.length) {
          setStatus(statusEl.textContent + "\n\n❌ All items invalid after buildGeometry().");
          return;
        }

        const graphics = items.map(x => x.graphic);
        view.graphics.addMany(graphics);

        async function goToAll() {
          try {
            const extents = graphics
              .map(g => g.geometry && g.geometry.extent)
              .filter(Boolean);
            const full = Extent.union(extents);
            await view.goTo({ target: full.expand(1.2) }, { duration: 650 });
          } catch (e) {
            try {
              await view.goTo(graphics.map(g => g.geometry), { padding: 60 });
            } catch (_) {}
          }
        }

        await goToAll();
        setStatus(statusEl.textContent + "\n✅ Map rendered (polygons + circles).");

        // ✅ Buttons
        if (items.length > 1) {
          controlsEl.style.display = "flex";
          controlsEl.innerHTML = "";

          const btnAll = document.createElement("button");
          btnAll.className = "primary";
          btnAll.textContent = "Show All";
          btnAll.onclick = () => goToAll();
          controlsEl.appendChild(btnAll);

          items.forEach((item, idx) => {
            const btn = document.createElement("button");
            btn.textContent = item.loc.name || `Location ${idx + 1}`;
            btn.title = "Zoom to " + btn.textContent;

            btn.onclick = async () => {
              try {
                const ext = item.graphic.geometry && item.graphic.geometry.extent;
                if (!ext) return;
                await view.goTo({ target: ext.expand(1.35) }, { duration: 650 });
                if (view.zoom > 16) view.zoom = 16;
              } catch (_) {}
            };

            controlsEl.appendChild(btn);
          });
        }
      });
    });
  </script>
</body>
</html>
